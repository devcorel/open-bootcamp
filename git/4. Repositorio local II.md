**git add nombrefichero.txt**: para añadir un solo archivo al _**stage area**_

**git log --online**: para ver el historial en de forma resumida

**HEAD**: nos dirá en qué posición estamos dentro del historial de commits, por default siempre se posiciona en el último commit que hicimos.

<br/>

## GIT RESET **\*Regresar en el tiempo**.

#### **\*Nota**: Al regresar en el tiempo, los commits que hayan quedado por delante, se borrarán, es decir se sobrescribe el historial de cambios.

-  **Sintaxis**:

   -  **git reset [--soft | --hard] HEAD~No.Commits**

-  ### **git reset --soft**:

   Apunta el **HEAD** a otro commit hacia atras.

   **\*NOTA**: Con **--soft** los ficheros que se hayan creado no se borrarán, permanecen en nuestra carpeta.

   -  **Ejemplo**:
      -  **git log--online**: para ver el hisotiral de commits, supongamos que tenemos 8 commits
      -  **git reset --soft HEAD~3**: Regresamos en el tiempo cuando teniamos los cambios **3 commits** atras. Es decir, nos posiciona en los cambios que tenemos en el commit **5**.

-  ### **git reset --hard**:

   **\*NOTA**: Con **--hard** los ficheros que se hayan creado sí se borrarán. Cuidado.

   -  **Ejemplo**:

      -  **git log--online**: para ver el hisotiral de commits, supongamos que tenemos 5 commits:

         -  En el commit 3 se crearon 4 archivos.
         -  En el commit 4 se añadieron 5 archivos más.

      -  **git reset --hard HEAD~3**: Se borran los commits **5, 4 y 3** quedándonos posicionados en el commit **2**, por lo tanto también se han borrado los ficheros que habíamos creado en los commits **3 y 4**.

      -  **git reset --hard (sin parámetros)**: Resetea hacia el último commit conocido en git de tu carpeta local

<br/>

## GIT DIFF

-  **git diff**: Muestra las diferencias que hay entre nuestra copia de trabajo con el repositorio local. Es decir, muestra los cambios que hemos hecho y que no hemos _commiteado_ (confirmado) con los que ya se encuentran confirmados en nuestro repositorio.

   **\*NOTA**: Si enviamos los cambios al área de preparación (_**staged area**_) con **git add**, **git diff** no mostrará las diferencias porque no compara el area de preparación, podría parecer que todo está actualizado pero los firechros en _**staged area**_ todavía son diferentes al respositorio.

   Para resolver ésta problemática se añade al comando la banderilla **--staged**.

-  **git diff --staged**: Compara las diferencias que tenemos en el área de preparación (_**staged area**_) con nuestro repositorio local.

<br/>

## GIT BISECT

Sirve para encontrar en qué **commit** se ha roto algo. Disecciona los cambios entre un commit y otro.

En tu terminal utiliza **git bisect** para ver las opciones disponibles.

### Ejemplo:

Supongamos que estamos programando una calculadora y nos damos cuenta que la **función para restar** dejó de funcionar.

-  **12f68o1** - nombre corto de un commit para éste ejemplo
-  **ae452b2** - nombre corto de un commit para éste ejemplo

1. **git bisect start** - parecerá que no está pasando nada
2. **git bisect good 12f68o1** - Seleccionamos el último commit en donde la **función restar** funcionaba **bien**. Notese la opción **good** en el comando.
   -  **nota**: Se puede especificar el commit usando el SHA, tag o branch del commit, o simplemente haciendo un checkout a un commit en concreto y marcarlo como bueno:
   ```
   git checkout 12f68o1
   git bisect good
   ```
3. **git bisect bad ae452b2** - Seleccionamos el commit en el que dejó de funcionar. Notese la opción **bad** en el comando.
   -  **nota**: Si no especificamos el nombre de un commit, tomará el commit actual como el **bad** commit.
4. Git comenzará a mostrarnos commit por commit y nos arrojará en la terminal algo parecido a esto:

```
Bisecting: 191 revisions left to test after this (roughly 8 steps)
[commit_123] Add new transaction endpoint
```

5. Validamos si los cambios en el commit en cuestion (commit_123) contiene la función buena o mala. Si la función aún funciona en éste commit typeamos **git bisect good** y git nos mostrará el siguiente commit a evaluar y así sucesivamente hasta que demos con el fallo.

6. Para finalizar, basta con typear **git bisect reset** para salir del algoritmo o por si queremos empezar de nuevo.

<br/>

## GIT BLAME

Nos permite saber **quién** ha hecho **qué** en qué **fecha y hora**

### Sintaxis:

-  **git blame**:
   retorna: **hash comit (Author fehca hora) cambio introducido**

### Ejemplo:

-  **git blame**

   Mostrará en la terminal:

   **23sd3f ( Isael Vazquez 2022-10-02 05:27:54 ) let foo = 1**

   **3afd4h ( Julia Rodriguez 2022-10-05 05:27:54 ) deleted doo = true**

<br/>

## RAMAS

Una rama es una **bifurcación** de mi historial de confirmaciones.
Se utilizan para tener multiples versiones de desarrollo.

Podemos crear una rama para arreglar un bug y cuando termineos podemos añadir esos cambios a la rama principal de nuestro código.

### Sintaxis:

-  **git branch**:

   Muestra las ramas actuales.

-  **git branch nombre-rama**:

   Creará una nueva rama llamada nombre-rama

   -  **NOTA**: Debes tener los últimos cambios confirmados, es decir que si tenemos cambios en el _**stage area**_, no podremos crear nuevas ramas hasta que éstos hayan sido confirmados (deben tener su commit).

-  **git checkout nombre-rama**:

   Con **git checkout** podemos cambiarnos entre ramas. Es decir, cambia la posición del puntero **HEAD** hacia la rama que le indiquemos.

Existe otra forma más de crear ramas y es con un solo comando que combina **git branch y git checkout** en una sola línea:

-  **git checkout -b nombre-rama**:
   Forma resumida para crear nuevas ramas.

**NOTA**: Se pueden crear ramas desde cualquier commit, sea previo o actual.

### Trabajar con **ramas remotas**:

-  **git pull origin nombre-rama**

   ij
